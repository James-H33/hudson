From 55d2ffe2e73e425f3f0284b54b8b1c5da6cb363a Mon Sep 17 00:00:00 2001
From: Shareef Ali <shareefalis@cyanogenmod.org>
Date: Thu, 1 Aug 2013 09:55:20 -0500
Subject: [PATCH] Camera: Bring Samsung camera fixes and features to 4.3

Squashed commit of the following:

commit 2f774cdc9f056ee7688f0fbb60624eb1baddb41f
Author: codeworkx <codeworkx@cyanogenmod.org>
Date:   Mon Dec 10 22:50:41 2012 +0100

    camera: add support for samsung and htc camcorder modes

    Change-Id: I68e6995a51dffa3b5851eb4b7a3a72e60d201d5b

commit 2f0e1b5a87b4625280deeed168b4acdca703e729
Author: Steve Kondik <shade@chemlab.org>
Date:   Tue Feb 12 13:30:57 2013 -0500

    camera: Add options to better control video preview size

     * usePreferredPreviewSizeForEffects is needed to fix camcorder effect on
       some MSM8660 devices.
     * Add ignorePreferredPreviewSizeForVideo to use the best size reported
       by the driver instead of the preferred-preview-size-for-video value,
       which may report something really awful.

    Adapted for cm-10.1 from similar commits in jellybean.
      https://github.com/CyanogenMod/android_packages_apps_Camera/commit/5ea90585dfce5a38f0c91d2ae07145770a0ea569
      https://github.com/CyanogenMod/android_packages_apps_Camera/commit/7310af07d00910033adbd2dce6aaf8b04cd1f220

    Change-Id: I58d4f81333a26dbd6d1ce35037b9c32fbd7d5b69

    Conflicts:
    	src/com/android/camera/VideoModule.java

commit 8969fd7025f166ee55c7fe5fe9964690c69b7a10
Author: codeworkx <codeworkx@cyanogenmod.org>
Date:   Mon Dec 10 23:04:04 2012 +0100

    camera: allow setting video-size before recording starts

    Needed for some samsung cameras.

    Change-Id: Ib87071bdd900aa1a42253bf6e2038b0af51f065b

    Conflicts:
    	res/values/config.xml
    	src/com/android/camera/CameraSettings.java
    	src/com/android/camera/Util.java
    	src/com/android/camera/VideoModule.java

commit 7cb706a3e5291b402c537f84ea30f5f8dca58e53
Author: Ricardo Cerqueira <cyanogenmod@cerqueira.org>
Date:   Wed Jul 31 10:02:22 2013 -0400

    Many camera HAL's stop the preview while taking a picture without generating events to upper layers
    Use "previewStopsDuringSnapshot" to avoid sending a stop while it is already stopped

    Forwarded from 10.1 camera - original commit 115d7184ee43703e4fcd3c248beea9b4090d0111

    PatchSet2 : credit original Author
    PatchSet3 : rebase to depend on 4.3 changes commit
    PatchSet4 : remove trailing spaces

    Change-Id: Ie7defc85d31bbbd9d132b8b488014b880cc1640d

commit afe0881439dedcd0fd665a8813c6260882b2a4cf
Author: Shareef Ali <shareefalis@cyanogenmod.org>
Date:   Sun Jul 28 12:37:36 2013 -0500

    Camera: fix derp and upgrade to 4.3 API

    Change-Id: I8079e35e753edbbcfd36d3d8a173e831621a5481

commit 7f11966b79c646c9ddf38634ad0726ad73befe8d
Author: Shareef Ali <shareefalis@cyanogenmod.org>
Date:   Mon Jul 22 03:08:42 2013 -0500

    Camera: HDR: don't reset focus manager when HDR is active.

    HDR takes time to compute. So disable any refernce to zsl except
    for actual take it in zsl command.
    due to a recent commit http://review.cyanogenmod.org/#/c/45730/
    I didn't know it was merged in less than 24 hours as HDR commit.

    Change-Id: I2aa3f4146575329c6fefb259b099371080842dab

commit b2ecd462457040a3408fe88079f6069013c31377
Author: Dheeraj CVR <cvr.dheeraj@gmail.com>
Date:   Thu Jul 18 14:40:48 2013 -0700

    camera: fix image capture review mode when zsl is enabled

    Choosing "Take Photo" to change a contact image doesn't show
    the captured imaged after taking a snap if ZSL is enabled.
    Also observed on apps that use the native camera to capture
    an image like Whatsapp.

    In ZSL mode, the preview is not stopped, due to which the
    review mode (ImageCapture) doesn't show the captured frame.
    Hence stop the preview if ZSL mode is active so that the
    preview can be restarted using the onReviewRetakeClicked().

    Also, reset the autofocus and set the camera to idle only
    when the ZSL mode is active. This fixes issues with non ZSL
    cameras where autofocus works even during the review mode
    after taking the snap since the camera state is set to idle.

    Change-Id: I2aa3f4146575329c6fefb259b09937108084fdab

commit 09a082533d7224443f5f7b0e41cc67a09af2b1d2
Author: Dheeraj CVR <cvr.dheeraj@gmail.com>
Date:   Wed Jul 24 18:34:42 2013 -0700

    camera: dont call cancelAutoFocus if the preview is stopped

    Most sensors cant cancel autofocus when preview
    is stopped.

    Change-Id: I66c2ddcedf3ed42a00e8364daab2b2906ba3301c

commit 5076f24ac501900692f3aaef6cfa0ba45deaaf6c
Author: Shareef Ali <shareefalis@cyanogenmod.org>
Date:   Fri Jul 19 23:53:01 2013 -0500

    Camera: HDR:  fix rotation issues.

    * fix fake rotate with real rotate by replacing the image with actual rotated image.
    * ps2: add more rotation mode

    Change-Id: I751cee4b9694180912d3bb0509fd12e295fbcb18

commit 41222dc4557a7e57f22149db7a9d80f61701682a
Author: Shareef Ali <shareefalis@cyanogenmod.org>
Date:   Sat Jul 13 22:29:23 2013 -0500

    Camera: HDR: fix low exposure on samsung hardware.

    /* samsung actually speficify max HDR range via exposure compinsation */
    Change-Id: I48b31965cf5acb6b9abcd2a62b1d341bfcab649c

commit de966f526165c3482445a6b506ab2184caff5a12
Author: Shareef Ali <shareefalis@cyanogenmod.org>
Date:   Thu Jul 4 02:45:09 2013 -0500

    Camera: HDR: convert YUV422P / YV16 format to JPEG

    Change-Id: I6310793e5e2d10e2d5e3d374aafe9761273259fc

commit 178ef452b7d2d9140a12eedf9f93e11a9c76465b
Author: Shareef Ali <shareefalis@cyanogenmod.org>
Date:   Tue Jun 25 18:39:36 2013 -0500

    camera: reset camera surface on previewstart()

    fixes aspect ratio on camera switch bug

    JIRA: CYAN-1085

    Change-Id: Ic91e0454588a987e72e5336ab9d01bdd249f13e6

    Conflicts:
    	src/com/android/camera/PhotoController.java
    	src/com/android/camera/PhotoModule.java
    	src/com/android/camera/Util.java
    	src/com/android/camera/VideoController.java
    	src/com/android/camera/VideoModule.java

commit 3fc823f6b47228ab9843d828dd983bc2b1dd8e3e
Author: Jorge Ruesga <jorge@ruesga.com>
Date:   Sat May 25 21:46:43 2013 +0200

    Camera: Wait for camera initialization

    Patchset 2: Capture specific exceptions instead of a generic exception

    Change-Id: Id62d0dedc630c3815dca7b101fdbf731154be3ca
    JIRA: CYAN-1190
    Issue: https://jira.cyanogenmod.org/browse/CYAN-1190
    Signed-off-by: Jorge Ruesga <jorge@ruesga.com>

commit 65dd92063dcdede7e053ca0ec36f4f453c3d4391
Author: Steve Kondik <shade@chemlab.org>
Date:   Wed May 8 11:35:20 2013 -0700

    camera: Fix hang when changing picture size

    Change-Id: I46d060d470b96be56d84f273accf54702e72b321

commit 66003f2c1f73ce7857ca3aee52db1c8870ac8a8e
Author: Steve Kondik <shade@chemlab.org>
Date:   Sat May 4 03:17:08 2013 -0700

    camera: Add support for ZSL on new Samsung devices

     * The camera driver on new Samsung devices requires that we send a
       magic command to the hardware in order to get ZSL behavior with
       continuous preview. On previous devices, this worked as long as the
       "cam_mode" parameter was zero (instead of null) and "camera-mode" is
       set to 1. On JF, we need to do all of these things.
     * The command we need to send is 1508, but I do not know what this
       value actually corresponds to. It was discovered by reverse
       engineering.

    Change-Id: I6bccc9cd228784045eef81719892121749af4fa5

commit 57f2a7a15eaa1979a17fe0f074c258c03e90baee
Author: Steve Kondik <shade@chemlab.org>
Date:   Wed Feb 29 12:59:19 2012 -0800

    camera: Restart the preview if record size changes

      * Needed to release the buffers on many cameras when the record size
        changes but the preview size does not. Without releasing the buffers,
        we can run out of ION space and end up with a mangled recording.

    Change-Id: I3ebee850b3e20b3920368c8e052a428f6dd9e3e5

commit c359b9edc7a089965a425efe80a59a9a268fce5a
Author: Steve Kondik <shade@chemlab.org>
Date:   Sat Dec 15 20:31:59 2012 -0800

    camera: Add ZSL support for Samsung/Qualcomm cameras

     * Preview management for Samsung/Qualcomm cameras
     * Add workaround for broken face detection on front camera

    Change-Id: Ib36bd21c9a76b45bced3eee2f25acc35b5d82b30

commit 637e1c973abc0b231722c9eb177abb108da50cad
Author: Ricardo Cerqueira <github@cerqueira.org>
Date:   Mon Dec 10 10:15:22 2012 +0700

    Camera: Allow a device to request the focus modes at build time

    By default, if a HAL supports touch-to-focus, mode selection is
    disabled. Make that an option for devices where manual modes
    work better without TTF (Macro, for instance)

Change-Id: Id47fba2a9d156b157440485a0fa516871076d9f9
---
 Android.mk                                      |   2 -
 res/values/config.xml                           |  26 +++
 src/com/android/camera/CameraActivity.java      |  36 +++++
 src/com/android/camera/CameraManager.java       |  14 ++
 src/com/android/camera/CameraSettings.java      |  28 +++-
 src/com/android/camera/FocusOverlayManager.java |   3 +-
 src/com/android/camera/PhotoModule.java         | 204 +++++++++++++++++++-----
 src/com/android/camera/Util.java                | 106 ++++++++++++
 src/com/android/camera/VideoModule.java         |  37 ++++-
 9 files changed, 403 insertions(+), 53 deletions(-)

diff --git a/Android.mk b/Android.mk
index c17ee04..9643f32 100644
--- a/Android.mk
+++ b/Android.mk
@@ -31,8 +31,6 @@ LOCAL_PACKAGE_NAME := Gallery2
 
 LOCAL_OVERRIDES_PACKAGES := Gallery Gallery3D GalleryNew3D
 
-LOCAL_SDK_VERSION := current
-
 # If this is an unbundled build (to install seprately) then include
 # the libraries in the APK, otherwise just put them in /system/lib and
 # leave them out of the APK
diff --git a/res/values/config.xml b/res/values/config.xml
index 33e1e14..675b7b0 100644
--- a/res/values/config.xml
+++ b/res/values/config.xml
@@ -19,4 +19,30 @@
 <resources>
     <!-- Maximum recording length in milliseconds. 0 means unlimited. -->
     <integer name="max_video_recording_length">0</integer>
+    <!-- The camera removes the focus modes by default when touch-to-focus
+         exists. Use this option to change that behavior -->
+    <bool name="wantsFocusModes">false</bool>
+    <!-- Always use preferred preview size path for effects recording instead
+         of the display resolution -->
+    <bool name="usePreferredPreviewSizeForEffects">false</bool>
+    <!-- Ignore preferred preview size and use best value from supported preview
+         sizesting both this and the above option true will always use values
+         from preview sizes for both -->
+    <bool name="ignorePreferredPreviewSizeForVideo">false</bool>
+    <!-- Disable face detection on the front camera -->
+    <bool name="noFaceDetectOnFrontCamera">false</bool>
+    <!-- Use ZSL mode for Qualcomm cameras -->
+    <bool name="enableZSL">false</bool>
+    <!-- Magic for enabling ZSL on Samsung cameras -->
+    <bool name="sendMagicSamsungZSLCommand">false</bool>
+    <!-- Decode YV16 format on Samsung HDR hardware -->
+    <bool name="needsSamsungHDRFormat">false</bool>
+    <!-- The camera HAL does its own preview state management during snaps -->
+    <bool name="previewStopsDuringSnapshot">false</bool>
+    <!-- Allows setting video size before recording starts -->
+    <bool name="needsEarlyVideoSize">false</bool>
+    <!-- Samsung Camcorder Mode -->
+    <bool name="needsSamsungCamMode">false</bool>
+    <!-- HTC Camcorder Mode -->
+    <bool name="needsHTCCamMode">false</bool>
 </resources>
diff --git a/src/com/android/camera/CameraActivity.java b/src/com/android/camera/CameraActivity.java
index 5ba769a..8924d11 100644
--- a/src/com/android/camera/CameraActivity.java
+++ b/src/com/android/camera/CameraActivity.java
@@ -25,7 +25,9 @@ import android.content.Intent;
 import android.content.ServiceConnection;
 import android.content.pm.ActivityInfo;
 import android.content.res.Configuration;
+import android.graphics.SurfaceTexture;
 import android.graphics.drawable.Drawable;
+import android.hardware.Camera;
 import android.os.Bundle;
 import android.os.IBinder;
 import android.provider.MediaStore;
@@ -63,6 +65,7 @@ public class CameraActivity extends ActivityBase
     private MotionEvent mDown;
     private boolean mAutoRotateScreen;
     private int mHeightOrWidth = -1;
+    private int mLastTextureCameraId = -1;
 
     private MyOrientationEventListener mOrientationListener;
     // The degrees of the device rotated clockwise from its natural orientation.
@@ -204,6 +207,7 @@ public class CameraActivity extends ActivityBase
         CameraHolder.instance().keep();
         closeModule(mCurrentModule);
         mCurrentModuleIndex = i;
+        mLastTextureCameraId = -1;
         switch (i) {
             case VIDEO_MODULE_INDEX:
                 mCurrentModule = new VideoModule();
@@ -517,6 +521,38 @@ public class CameraActivity extends ActivityBase
         return (mCurrentModuleIndex == PANORAMA_MODULE_INDEX);
     }
 
+    public SurfaceTexture getScreenNailTextureForPreviewSize(int cameraId,
+            int displayOrientation, Camera.Parameters parameters) {
+        CameraScreenNail screenNail = getCameraScreenNail();
+        Camera.Size size = parameters.getPreviewSize();
+        int previewWidth, previewHeight;
+
+        if ((displayOrientation % 180) != 0) {
+            previewWidth = size.height;
+            previewHeight = size.width;
+        } else {
+            previewWidth = size.width;
+            previewHeight = size.height;
+        }
+
+        if (screenNail.getSurfaceTexture() == null || mLastTextureCameraId != cameraId) {
+            mLastTextureCameraId = cameraId;
+            screenNail.releaseSurfaceTexture();
+            screenNail.setSize(previewWidth, previewHeight);
+            screenNail.enableAspectRatioClamping();
+            notifyScreenNailChanged();
+            screenNail.acquireSurfaceTexture();
+        } else {
+            if (screenNail.getWidth() != previewWidth || screenNail.getHeight() != previewHeight) {
+                screenNail.setSize(previewWidth, previewHeight);
+            }
+            screenNail.enableAspectRatioClamping();
+            notifyScreenNailChanged();
+        }
+
+        return screenNail.getSurfaceTexture();
+    }
+
     // Accessor methods for getting latency times used in performance testing
     public long getAutoFocusTime() {
         return (mCurrentModule instanceof PhotoModule) ?
diff --git a/src/com/android/camera/CameraManager.java b/src/com/android/camera/CameraManager.java
index c7005cf5..fb9597e 100644
--- a/src/com/android/camera/CameraManager.java
+++ b/src/com/android/camera/CameraManager.java
@@ -20,11 +20,13 @@ import static com.android.camera.Util.Assert;
 
 import android.annotation.TargetApi;
 import android.graphics.SurfaceTexture;
+import android.hardware.Camera;
 import android.hardware.Camera.AutoFocusCallback;
 import android.hardware.Camera.AutoFocusMoveCallback;
 import android.hardware.Camera.ErrorCallback;
 import android.hardware.Camera.FaceDetectionListener;
 import android.hardware.Camera.OnZoomChangeListener;
+import android.hardware.Camera.OnZoomChangeListener;
 import android.hardware.Camera.Parameters;
 import android.hardware.Camera.PictureCallback;
 import android.hardware.Camera.PreviewCallback;
@@ -73,6 +75,8 @@ public class CameraManager {
     private static final int ENABLE_SHUTTER_SOUND = 23;
     private static final int REFRESH_PARAMETERS = 24;
 
+    private static final int ENABLE_SAMSUNG_ZSL_MODE = 30;
+
     private Handler mCameraHandler;
     private android.hardware.Camera mCamera;
 
@@ -252,6 +256,12 @@ public class CameraManager {
                         mParametersIsDirty = true;
                         return;
 
+                    case ENABLE_SAMSUNG_ZSL_MODE:
+                        // I don't know the significance of 1508, it was discovered
+                        // by reading logs and reverse engineering.
+                        mCamera.sendRawCommand(1508, 0, 0);
+                        break;
+
                     default:
                         throw new RuntimeException("Invalid CameraProxy message=" + msg.what);
                 }
@@ -477,5 +487,9 @@ public class CameraManager {
             }
             return true;
         }
+
+        public void sendMagicSamsungZSLCommand() {
+            mCameraHandler.sendEmptyMessage(ENABLE_SAMSUNG_ZSL_MODE);
+        }
     }
 }
diff --git a/src/com/android/camera/CameraSettings.java b/src/com/android/camera/CameraSettings.java
index 4e9a5dd..bb8efe6 100644
--- a/src/com/android/camera/CameraSettings.java
+++ b/src/com/android/camera/CameraSettings.java
@@ -201,7 +201,7 @@ public class CameraSettings {
             if (!Util.isFocusAreaSupported(mParameters)) {
                 filterUnsupportedOptions(group,
                         focusMode, mParameters.getSupportedFocusModes());
-            } else {
+            } else if (!mContext.getResources().getBoolean(R.bool.wantsFocusModes)) {
                 // Remove the focus mode if we can use tap-to-focus.
                 removePreference(group, focusMode.getKey());
             }
@@ -565,6 +565,32 @@ public class CameraSettings {
         }
     }
 
+    /**
+     * Set video size for certain cameras.
+     *
+     * @param params
+     * @param profile
+     */
+    public static void setEarlyVideoSize(Parameters params, CamcorderProfile profile) {
+        if (Util.needsEarlyVideoSize()) {
+            params.set("video-size", profile.videoFrameWidth + "x" + profile.videoFrameHeight);
+        }
+    }
+     /**
+     * Enable video mode for certain cameras.
+     *
+     * @param params
+     * @param on
+     */
+    public static void setVideoMode(Parameters params, boolean on) {
+        if (Util.useSamsungCamMode()) {
+            params.set("cam_mode", on ? "1" : "0");
+        }
+        if (Util.useHTCCamMode()) {
+            params.set("cam-mode", on ? "1" : "0");
+        }
+    }
+
     private void initVideoEffect(PreferenceGroup group, ListPreference videoEffect) {
         CharSequence[] values = videoEffect.getEntryValues();
 
diff --git a/src/com/android/camera/FocusOverlayManager.java b/src/com/android/camera/FocusOverlayManager.java
index 8bcb52f..452684b 100644
--- a/src/com/android/camera/FocusOverlayManager.java
+++ b/src/com/android/camera/FocusOverlayManager.java
@@ -553,6 +553,7 @@ public class FocusOverlayManager {
         String focusMode = getFocusMode();
         return !(focusMode.equals(Parameters.FOCUS_MODE_INFINITY)
                 || focusMode.equals(Parameters.FOCUS_MODE_FIXED)
-                || focusMode.equals(Parameters.FOCUS_MODE_EDOF));
+                || focusMode.equals(Parameters.FOCUS_MODE_EDOF)
+                || focusMode.equals(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE));
     }
 }
diff --git a/src/com/android/camera/PhotoModule.java b/src/com/android/camera/PhotoModule.java
index e88645d..79d72d2 100644
--- a/src/com/android/camera/PhotoModule.java
+++ b/src/com/android/camera/PhotoModule.java
@@ -27,6 +27,8 @@ import android.content.Intent;
 import android.content.SharedPreferences.Editor;
 import android.content.res.Configuration;
 import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.Matrix;
 import android.graphics.SurfaceTexture;
 import android.hardware.Camera.CameraInfo;
 import android.hardware.Camera.Parameters;
@@ -68,6 +70,7 @@ import com.android.gallery3d.filtershow.FilterShowActivity;
 import com.android.gallery3d.filtershow.crop.CropExtras;
 import com.android.gallery3d.util.UsageStatistics;
 
+import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
@@ -90,6 +93,9 @@ public class PhotoModule
 
     private static final String TAG = "CAM_PhotoModule";
 
+    private boolean mRestartPreview = false;
+    private boolean mAspectRatioChanged = false;
+
     // We number the request code from 1000 to avoid collision with Gallery.
     private static final int REQUEST_CROP = 1000;
 
@@ -250,6 +256,8 @@ public class PhotoModule
     private final Handler mHandler = new MainHandler();
     private PreferenceGroup mPreferenceGroup;
 
+    private int mResetExposure;
+
     private boolean mQuickCapture;
 
     CameraStartUpThread mCameraStartUpThread;
@@ -456,6 +464,7 @@ public class PhotoModule
 
     private void onPreviewStarted() {
         mCameraStartUpThread = null;
+        mResetExposure = mParameters.getExposureCompensation();
         setCameraState(IDLE);
         if (!ApiHelper.HAS_SURFACE_TEXTURE) {
             // This may happen if surfaceCreated has arrived.
@@ -701,10 +710,17 @@ public class PhotoModule
     @Override
     public void startFaceDetection() {
         if (!ApiHelper.HAS_FACE_DETECTION) return;
-        if (mFaceDetectionStarted) return;
+
+        CameraInfo info = CameraHolder.instance().getCameraInfo()[mCameraId];
+
+        // Workaround for a buggy camera library
+        if (Util.noFaceDetectOnFrontCamera() && info.facing == CameraInfo.CAMERA_FACING_FRONT) {
+            return;
+        }
+
+        if (mFaceDetectionStarted || mCameraState != IDLE) return;
         if (mParameters.getMaxNumDetectedFaces() > 0) {
             mFaceDetectionStarted = true;
-            CameraInfo info = CameraHolder.instance().getCameraInfo()[mCameraId];
             mUI.onStartFaceDetection(mDisplayOrientation,
                     (info.facing == CameraInfo.CAMERA_FACING_FRONT));
             mCameraDevice.setFaceDetectionListener(mUI);
@@ -781,7 +797,7 @@ public class PhotoModule
 
         @Override
         public void onPictureTaken(
-                final byte [] jpegData, final android.hardware.Camera camera) {
+                byte [] jpegData, final android.hardware.Camera camera) {
             if (mPaused) {
                 return;
             }
@@ -820,7 +836,11 @@ public class PhotoModule
                         CaptureAnimManager.getAnimationDuration());
             }
             mFocusManager.updateFocusUI(); // Ensure focus indicator is hidden.
-            if (!mIsImageCaptureIntent) {
+
+            boolean isSamsungHDR =
+                    (mSceneMode == Util.SCENE_MODE_HDR && Util.needSamsungHDRFormat());
+
+            if (!mIsImageCaptureIntent && (!Util.isZSLEnabled() || isSamsungHDR)) {
                 if (ApiHelper.CAN_START_PREVIEW_IN_JPEG_CALLBACK) {
                     setupPreview();
                 } else {
@@ -829,6 +849,17 @@ public class PhotoModule
                     // time before starting the preview.
                     mHandler.sendEmptyMessageDelayed(SETUP_PREVIEW, 300);
                 }
+            } else if (Util.isZSLEnabled() && !isSamsungHDR) {
+                // In ZSL mode, the preview is not stopped, due to which the
+                // review mode (ImageCapture) doesn't show the captured frame.
+                // Hence stop the preview if ZSL mode is active so that the
+                // preview can be restarted using the onReviewRetakeClicked().
+                if (mIsImageCaptureIntent) {
+                    stopPreview();
+                } else {
+                    mFocusManager.resetTouchFocus();
+                    setCameraState(IDLE);
+                }
             }
 
             if (!mIsImageCaptureIntent) {
@@ -837,7 +868,9 @@ public class PhotoModule
                 ExifInterface exif = Exif.getExif(jpegData);
                 int orientation = Exif.getOrientation(exif);
                 int width, height;
-                if ((mJpegRotation + orientation) % 180 == 0) {
+                if ((mJpegRotation + orientation) % 180 == 0 ||
+                        (mSceneMode == Util.SCENE_MODE_HDR &&
+                            Util.needSamsungHDRFormat())) {
                     width = s.width;
                     height = s.height;
                 } else {
@@ -861,6 +894,42 @@ public class PhotoModule
                         exif.setTag(directionRefTag);
                         exif.setTag(directionTag);
                     }
+
+                    if (isSamsungHDR) {
+                        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+                        Bitmap bm = Util.decodeYUV422P(jpegData, width, height);
+                        if (mJpegRotation != 0) {
+                            Matrix matrix = new Matrix();
+                            matrix.postRotate(mJpegRotation);
+                            bm = Bitmap.createBitmap(bm, 0, 0, width, height, matrix, true);
+                        }
+                        if (mJpegRotation % 180 != 0) {
+                            int x = height;
+                            int y = width;
+                            width = x;
+                            height = y;
+                        }
+                        String quality = mPreferences.getString(CameraSettings.KEY_JPEG_QUALITY,
+                                                                "85");
+
+                        if (quality.equals("normal")) {
+                            quality = "65";
+                        } else if (quality.equals("fine")) {
+                            quality = "75";
+                        } else {
+                            try {
+                                Integer.parseInt(quality);
+                            } catch (Exception e) {
+                                quality = "85";
+                            }
+                        }
+
+                        bm.compress(Bitmap.CompressFormat.JPEG,
+                                    Integer.parseInt(quality),
+                                    baos);
+
+                        jpegData = baos.toByteArray();
+                    }
                     mActivity.getMediaSaveService().addImage(
                             jpegData, title, date, mLocation, width, height,
                             orientation, exif, mOnMediaSavedListener, mContentResolver);
@@ -885,6 +954,10 @@ public class PhotoModule
             Log.v(TAG, "mJpegCallbackFinishTime = "
                     + mJpegCallbackFinishTime + "ms");
             mJpegPictureCallbackTime = 0;
+
+            // reset exposure
+            mParameters.setExposureCompensation(mResetExposure);
+            mCameraDevice.setParameters(mParameters);
         }
     }
 
@@ -1001,6 +1074,8 @@ public class PhotoModule
             animateFlash();
         }
 
+        //save data
+        mResetExposure = mParameters.getExposureCompensation();
         // Set rotation and gps data.
         int orientation;
         // We need to be consistent with the framework orientation (i.e. the
@@ -1011,6 +1086,11 @@ public class PhotoModule
             orientation = mOrientation;
         }
         mJpegRotation = Util.getJpegRotation(mCameraId, orientation);
+        if (mSceneMode == Util.SCENE_MODE_HDR && Util.needSamsungHDRFormat()) {
+            /* samsung actually speficify max range via exposure compinsation */
+            mParameters.setExposureCompensation(mParameters.getMaxExposureCompensation());
+        }
+        mJpegRotation = Util.getJpegRotation(mCameraId, mOrientation);
         mParameters.setRotation(mJpegRotation);
         Location loc = mLocationManager.getCurrentLocation();
         Util.setGpsParameters(mParameters, loc);
@@ -1021,8 +1101,15 @@ public class PhotoModule
                 new JpegPictureCallback(loc), mCameraState,
                 mFocusManager.getFocusState());
 
+
         mNamedImages.nameNewImage(mContentResolver, mCaptureStartTime);
 
+        if (Util.isZSLEnabled() &&
+                (mSceneMode != Util.SCENE_MODE_HDR || !Util.needSamsungHDRFormat())) {
+            mRestartPreview = false;
+        }
+
+
         mFaceDetectionStarted = false;
         setCameraState(SNAPSHOT_IN_PROGRESS);
         UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,
@@ -1375,7 +1462,9 @@ public class PhotoModule
         }
         stopPreview();
         // Release surface texture.
-        ((CameraScreenNail) mActivity.mCameraScreenNail).releaseSurfaceTexture();
+        mActivity.getCameraScreenNail().releaseSurfaceTexture();
+
+        resetScreenOn();
 
         mNamedImages = null;
 
@@ -1433,6 +1522,16 @@ public class PhotoModule
     @Override
     public void onConfigurationChanged(Configuration newConfig) {
         Log.v(TAG, "onConfigurationChanged");
+
+        // Wait for camera initialization
+        try {
+            if (mCameraStartUpThread != null) {
+                mCameraStartUpThread.join();
+            }
+        } catch (InterruptedException iex) {
+            // Ignore.
+        }
+
         setDisplayOrientation();
     }
 
@@ -1597,14 +1696,18 @@ public class PhotoModule
         // ICS camera frameworks has a bug. Face detection state is not cleared
         // after taking a picture. Stop the preview to work around it. The bug
         // was fixed in JB.
-        if (mCameraState != PREVIEW_STOPPED) stopPreview();
-
+        if (mCameraState != PREVIEW_STOPPED &&
+                (!mActivity.getResources().getBoolean(R.bool.previewStopsDuringSnapshot) ||
+                 mCameraState != SNAPSHOT_IN_PROGRESS)) {
+            stopPreview();
+        }
         setDisplayOrientation();
 
-        if (!mSnapshotOnIdle) {
+        if (!mSnapshotOnIdle && !mAspectRatioChanged) {
             // If the focus mode is continuous autofocus, call cancelAutoFocus to
             // resume it because it may have been paused by autoFocus call.
-            if (Util.FOCUS_MODE_CONTINUOUS_PICTURE.equals(mFocusManager.getFocusMode())) {
+            if (Util.FOCUS_MODE_CONTINUOUS_PICTURE.equals(mFocusManager.getFocusMode())
+                    && mCameraState != PREVIEW_STOPPED) {
                 mCameraDevice.cancelAutoFocus();
             }
             mFocusManager.setAeAwbLock(false); // Unlock AE and AWB.
@@ -1612,30 +1715,24 @@ public class PhotoModule
         setCameraParameters(UPDATE_PARAM_ALL);
 
         if (ApiHelper.HAS_SURFACE_TEXTURE) {
-            CameraScreenNail screenNail = (CameraScreenNail) mActivity.mCameraScreenNail;
             if (mUI.getSurfaceTexture() == null) {
-                Size size = mParameters.getPreviewSize();
-                if (mCameraDisplayOrientation % 180 == 0) {
-                    screenNail.setSize(size.width, size.height);
-                } else {
-                    screenNail.setSize(size.height, size.width);
-                }
-                screenNail.enableAspectRatioClamping();
-                mActivity.notifyScreenNailChanged();
-                screenNail.acquireSurfaceTexture();
-                CameraStartUpThread t = mCameraStartUpThread;
-                if (t != null && t.isCanceled()) {
+                if (mCameraStartUpThread != null && mCameraStartUpThread.isCanceled()) {
                     return; // Exiting, so no need to get the surface texture.
                 }
-                mUI.setSurfaceTexture(screenNail.getSurfaceTexture());
-            } else {
-                updatePreviewSize(screenNail);
             }
+            SurfaceTexture texture = mActivity.getScreenNailTextureForPreviewSize(
+                    mCameraId, mCameraDisplayOrientation, mParameters);
+            mUI.setSurfaceTexture(texture);
             mCameraDevice.setDisplayOrientation(mCameraDisplayOrientation);
-            Object st = mUI.getSurfaceTexture();
-            if (st != null) {
-                mCameraDevice.setPreviewTextureAsync((SurfaceTexture) st);
+
+            if (texture == null) {
+                if (mCameraStartUpThread != null && mCameraStartUpThread.isCanceled()) {
+                    return; // Exiting, so no need to get the surface texture.
+                }
+            } else {
+                mCameraDevice.setPreviewTextureAsync(texture);
             }
+
         } else {
             mCameraDevice.setDisplayOrientation(mDisplayOrientation);
             mCameraDevice.setPreviewDisplayAsync(mUI.getSurfaceHolder());
@@ -1646,26 +1743,15 @@ public class PhotoModule
 
         mFocusManager.onPreviewStarted();
 
+        // Set camera mode
+        CameraSettings.setVideoMode(mParameters, false);
+        mCameraDevice.setParameters(mParameters);
+
         if (mSnapshotOnIdle) {
             mHandler.post(mDoSnapRunnable);
         }
     }
 
-    private void updatePreviewSize(CameraScreenNail snail) {
-        Size size = mParameters.getPreviewSize();
-        int w = size.width;
-        int h = size.height;
-        if (mCameraDisplayOrientation % 180 != 0) {
-            w = size.height;
-            h = size.width;
-        }
-        if (snail.getWidth() != w || snail.getHeight() != h) {
-            snail.setSize(w, h);
-        }
-        snail.enableAspectRatioClamping();
-        mActivity.notifyScreenNailChanged();
-    }
-
     @Override
     public void stopPreview() {
         if (mCameraDevice != null && mCameraState != PREVIEW_STOPPED) {
@@ -1745,9 +1831,18 @@ public class PhotoModule
         if (pictureSize == null) {
             CameraSettings.initialCameraPictureSize(mActivity, mParameters);
         } else {
+            Size oldSize = mParameters.getPictureSize();
             List<Size> supported = mParameters.getSupportedPictureSizes();
             CameraSettings.setCameraPictureSize(
                     pictureSize, supported, mParameters);
+            Size size = mParameters.getPictureSize();
+            if (oldSize != null && size != null) {
+                if (!size.equals(oldSize) && mCameraState != PREVIEW_STOPPED) {
+                    Log.d(TAG, "Picture size changed. Restart preview");
+                    mAspectRatioChanged = true;
+                    stopPreview();
+                }
+            }
         }
         Size size = mParameters.getPictureSize();
 
@@ -1800,6 +1895,14 @@ public class PhotoModule
             }
         }
 
+        if (Util.isZSLEnabled()) {
+            if (Util.sendMagicSamsungZSLCommand()) {
+                mCameraDevice.sendMagicSamsungZSLCommand();
+            }
+            // Switch on ZSL mode
+            mParameters.set("camera-mode", "1");
+        }
+
         // Set JPEG quality.
         int jpegQuality = CameraProfile.getJpegEncodingQualityParameter(mCameraId,
                 CameraProfile.QUALITY_HIGH);
@@ -1876,6 +1979,9 @@ public class PhotoModule
     private void setCameraParameters(int updateSet) {
         if ((updateSet & UPDATE_PARAM_INITIALIZE) != 0) {
             updateCameraParametersInitialize();
+
+            // Set camera mode
+            CameraSettings.setVideoMode(mParameters, false);
         }
 
         if ((updateSet & UPDATE_PARAM_ZOOM) != 0) {
@@ -1899,6 +2005,11 @@ public class PhotoModule
             mUpdateSet = 0;
             return;
         } else if (isCameraIdle()) {
+            if (mRestartPreview) {
+                Log.d(TAG, "Restarting preview");
+                startPreview();
+                mRestartPreview = false;
+            }
             setCameraParameters(mUpdateSet);
             updateSceneMode();
             mUpdateSet = 0;
@@ -1908,6 +2019,13 @@ public class PhotoModule
                         SET_CAMERA_PARAMETERS_WHEN_IDLE, 1000);
             }
         }
+        if (mAspectRatioChanged || mRestartPreview) {
+            Log.e(TAG, "Aspect ratio changed, restarting preview");
+            startPreview();
+            mAspectRatioChanged = false;
+            mRestartPreview = false;
+            mHandler.sendEmptyMessage(START_PREVIEW_DONE);
+        }
     }
 
     public boolean isCameraIdle() {
diff --git a/src/com/android/camera/Util.java b/src/com/android/camera/Util.java
index 44af425..3f153ec 100644
--- a/src/com/android/camera/Util.java
+++ b/src/com/android/camera/Util.java
@@ -135,6 +135,28 @@ public class Util {
     private static float sPixelDensity = 1;
     private static ImageFileNamer sImageFileNamer;
 
+
+    // Samsung ZSL mode
+    private static boolean sEnableZSL;
+
+    // Workaround for QC cameras with broken face detection on front camera
+    private static boolean sNoFaceDetectOnFrontCamera;
+
+    // Use samsung HDR format
+    private static boolean sSamsungHDRFormat;
+
+    // Send magic command to hardware for Samsung ZSL
+    private static boolean sSendMagicSamsungZSLCommand;
+
+    // For setting video size before recording starts
+    private static boolean sEarlyVideoSize;
+
+    // Samsung camcorder mode
+    private static boolean sSamsungCamMode;
+
+    // HTC camcorder mode
+    private static boolean sHTCCamMode;
+
     private Util() {
     }
 
@@ -146,12 +168,53 @@ public class Util {
         sPixelDensity = metrics.density;
         sImageFileNamer = new ImageFileNamer(
                 context.getString(R.string.image_file_name_format));
+
+        // These come from the config, but are needed before parameters are set.
+        sEnableZSL = context.getResources().getBoolean(R.bool.enableZSL);
+        sNoFaceDetectOnFrontCamera = context.getResources().getBoolean(
+                R.bool.noFaceDetectOnFrontCamera);
+
+        sSamsungHDRFormat = context.getResources().getBoolean(R.bool.needsSamsungHDRFormat);
+
+        sSendMagicSamsungZSLCommand = context.getResources().getBoolean(
+                R.bool.sendMagicSamsungZSLCommand);
+
+        sEarlyVideoSize = context.getResources().getBoolean(R.bool.needsEarlyVideoSize);
+        sSamsungCamMode = context.getResources().getBoolean(R.bool.needsSamsungCamMode);
+        sHTCCamMode = context.getResources().getBoolean(R.bool.needsHTCCamMode);
     }
 
     public static int dpToPixel(int dp) {
         return Math.round(sPixelDensity * dp);
     }
 
+    public static boolean isZSLEnabled() {
+        return sEnableZSL;
+    }
+
+    public static boolean needSamsungHDRFormat() {
+        return sSamsungHDRFormat;
+    }
+    public static boolean noFaceDetectOnFrontCamera() {
+        return sNoFaceDetectOnFrontCamera;
+    }
+
+    public static boolean sendMagicSamsungZSLCommand() {
+        return sSendMagicSamsungZSLCommand;
+    }
+
+    public static boolean needsEarlyVideoSize() {
+        return sEarlyVideoSize;
+    }
+
+    public static boolean useHTCCamMode() {
+        return sHTCCamMode;
+    }
+
+    public static boolean useSamsungCamMode() {
+        return sSamsungCamMode;
+    }
+
     // Rotates the bitmap by the specified degree.
     // If a new bitmap is created, the original bitmap is recycled.
     public static Bitmap rotate(Bitmap b, int degrees) {
@@ -282,6 +345,49 @@ public class Util {
         }
     }
 
+    public static Bitmap decodeYUV422P(byte[] yuv422p, int width, int height) {
+        final int frameSize = width * height;
+        int[] rgb = new int[frameSize];
+
+        for (int j = 0, yp = 0; j < height; j++) {
+            int up = frameSize + (j * (width / 2)), u = 0, v = 0;
+            int vp = ((int)(frameSize * 1.5) + (j * (width / 2)));
+            for (int i = 0; i < width; i++, yp++) {
+                int y = Math.max(0, (0xff & ((int) yuv422p[yp])) - 16);
+                if ((i & 1) == 0) {
+                    u = (0xff & yuv422p[up++]) - 128;
+                    v = (0xff & yuv422p[vp++]) - 128;
+                }
+
+                int y1192 = 1192 * y;
+                int r = (y1192 + 1634 * v);
+                int g = (y1192 - 833 * v - 400 * u);
+                int b = (y1192 + 2066 * u);
+
+                if (r < 0) {
+                    r = 0;
+                } else if (r > 262143) {
+                    r = 262143;
+                }
+                if (g < 0) {
+                    g = 0;
+                } else if (g > 262143) {
+                    g = 262143;
+                }
+                if (b < 0) {
+                    b = 0;
+                } else if (b > 262143) {
+                    b = 262143;
+                }
+                rgb[yp] = 0xff000000
+                        | ((r << 6) & 0xff0000)
+                        | ((g >> 2) & 0xff00)
+                        | ((b >> 10) & 0xff);
+            }
+        }
+        return Bitmap.createBitmap(rgb, width, height, Bitmap.Config.ARGB_8888);
+    }
+
     public static void closeSilently(Closeable c) {
         if (c == null) return;
         try {
diff --git a/src/com/android/camera/VideoModule.java b/src/com/android/camera/VideoModule.java
index 2eb3d1b..c9eeaf7 100644
--- a/src/com/android/camera/VideoModule.java
+++ b/src/com/android/camera/VideoModule.java
@@ -189,6 +189,9 @@ public class VideoModule implements CameraModule,
     private boolean mRestoreFlash;  // This is used to check if we need to restore the flash
                                     // status when going back from gallery.
 
+    private int mVideoWidth;
+    private int mVideoHeight;
+
     private final MediaSaveService.OnMediaSavedListener mOnVideoSavedListener =
             new MediaSaveService.OnMediaSavedListener() {
                 @Override
@@ -697,16 +700,27 @@ public class VideoModule implements CameraModule,
         editor.apply();
     }
 
+    private boolean cantUsePreviewSizeDueToEffects() {
+        if (!effectsActive()) {
+            return false;
+        }
+        return !mActivity.getResources().getBoolean(R.bool.usePreferredPreviewSizeForEffects);
+    }
+
     @TargetApi(ApiHelper.VERSION_CODES.HONEYCOMB)
     private void getDesiredPreviewSize() {
         mParameters = mActivity.mCameraDevice.getParameters();
         if (ApiHelper.HAS_GET_SUPPORTED_VIDEO_SIZE) {
-            if (mParameters.getSupportedVideoSizes() == null || effectsActive()) {
+            if (mParameters.getSupportedVideoSizes() == null || cantUsePreviewSizeDueToEffects()) {
                 mDesiredPreviewWidth = mProfile.videoFrameWidth;
                 mDesiredPreviewHeight = mProfile.videoFrameHeight;
             } else {  // Driver supports separates outputs for preview and video.
                 List<Size> sizes = mParameters.getSupportedPreviewSizes();
                 Size preferred = mParameters.getPreferredPreviewSizeForVideo();
+                if (mActivity.getResources().getBoolean(R.bool.ignorePreferredPreviewSizeForVideo)
+                        || preferred == null) {
+                    preferred = sizes.get(0);
+                }
                 int product = preferred.width * preferred.height;
                 Iterator<Size> it = sizes.iterator();
                 // Remove the preview sizes that are not preferred.
@@ -849,12 +863,13 @@ public class VideoModule implements CameraModule,
         try {
             if (!effectsActive()) {
                 if (ApiHelper.HAS_SURFACE_TEXTURE) {
-                    SurfaceTexture surfaceTexture = ((CameraScreenNail) mActivity.mCameraScreenNail)
-                            .getSurfaceTexture();
-                    if (surfaceTexture == null) {
+                    SurfaceTexture texture = mActivity.getScreenNailTextureForPreviewSize(
+                            mCameraId, mCameraDisplayOrientation, mParameters);
+
+                    if (texture == null) {
                         return; // The texture has been destroyed (pause, etc)
                     }
-                    mActivity.mCameraDevice.setPreviewTextureAsync(surfaceTexture);
+                    mActivity.mCameraDevice.setPreviewTextureAsync(texture);
                 } else {
                     mActivity.mCameraDevice.setPreviewDisplayAsync(mUI.getSurfaceHolder());
                 }
@@ -1141,6 +1156,9 @@ public class VideoModule implements CameraModule,
         Intent intent = mActivity.getIntent();
         Bundle myExtras = intent.getExtras();
 
+        mVideoWidth = mProfile.videoFrameWidth;
+        mVideoHeight = mProfile.videoFrameHeight;
+
         long requestedSizeLimit = 0;
         closeVideoFileDescriptor();
         if (mIsVideoCaptureIntent && myExtras != null) {
@@ -1803,6 +1821,11 @@ public class VideoModule implements CameraModule,
         mParameters.setPreviewSize(mDesiredPreviewWidth, mDesiredPreviewHeight);
         mParameters.setPreviewFrameRate(mProfile.videoFrameRate);
 
+        // Set video size before recording starts
+        CameraSettings.setEarlyVideoSize(mParameters, mProfile);
+        // Set video mode
+        CameraSettings.setVideoMode(mParameters, true);
+
         // Set flash mode.
         String flashMode;
         if (mActivity.mShowCameraAppView) {
@@ -2029,7 +2052,9 @@ public class VideoModule implements CameraModule,
             // We need to restart the preview if preview size is changed.
             Size size = mParameters.getPreviewSize();
             if (size.width != mDesiredPreviewWidth
-                    || size.height != mDesiredPreviewHeight) {
+                    || size.height != mDesiredPreviewHeight
+                    || mProfile.videoFrameWidth != mVideoWidth
+                    || mProfile.videoFrameHeight != mVideoHeight) {
                 if (!effectsActive()) {
                     stopPreview();
                 } else {
-- 
1.8.3.4

