From 3da7bdb9baa461b8de622a718bbb0f031780c5ec Mon Sep 17 00:00:00 2001
From: XpLoDWilD <xplodwild@cyanogenmod.org>
Date: Sat, 17 Aug 2013 00:43:49 +0200
Subject: [PATCH] Preview: Fix upside-down portrait preview

Change-Id: I4e459fd096fb8bdd7bb1162328171a43569d9d5b
---
 src/org/cyanogenmod/focal/CameraActivity.java  |  38 +----
 src/org/cyanogenmod/focal/CameraManager.java   | 206 ++++++++++---------------
 src/org/cyanogenmod/focal/Util.java            |  32 ++--
 src/org/cyanogenmod/focal/ui/ReviewDrawer.java | 193 ++++++++++++-----------
 4 files changed, 207 insertions(+), 262 deletions(-)

diff --git a/src/org/cyanogenmod/focal/CameraActivity.java b/src/org/cyanogenmod/focal/CameraActivity.java
index 5689125..245601e 100644
--- a/src/org/cyanogenmod/focal/CameraActivity.java
+++ b/src/org/cyanogenmod/focal/CameraActivity.java
@@ -602,6 +602,8 @@ public class CameraActivity extends Activity implements CameraManager.CameraRead
 
     @Override
     public void onCameraReady() {
+        mCamManager.updateDisplayOrientation();
+
         runOnUiThread(new Runnable() {
             @Override
             public void run() {
@@ -952,40 +954,12 @@ public class CameraActivity extends Activity implements CameraManager.CameraRead
     private class CameraPreviewListener implements CameraManager.PreviewPauseListener {
         @Override
         public void onPreviewPause() {
-            final PreviewFrameLayout container = (PreviewFrameLayout)
-                    findViewById(R.id.camera_preview_overlay_container);
-            final ImageView iv = (ImageView) findViewById(R.id.camera_preview_overlay);
-
-            if (iv.getAlpha() == 1.0f) {
-                return;
-            }
-
-            final Bitmap preview = mCamManager.getLastPreviewFrame();
-
-            if (preview == null) {
-                return;
-            }
-
-            runOnUiThread(new Runnable() {
-                @Override
-                public void run() {
-                    container.setPreviewSize(preview.getWidth(), preview.getHeight());
-                    iv.setImageBitmap(preview);
-                    iv.setAlpha(1.0f);
-                }
-            });
+            // XXX: Do a little animation
         }
 
         @Override
         public void onPreviewResume() {
-            mHandler.postDelayed(new Runnable() {
-                @Override
-                public void run() {
-                    findViewById(R.id.gl_renderer_container).setAlpha(1.0f);
-                    ImageView iv = (ImageView) findViewById(R.id.camera_preview_overlay);
-                    iv.animate().setDuration(300).alpha(0.0f).start();
-                }
-            }, 100);
+            // XXX: Do a little animation
         }
     }
 
@@ -1092,6 +1066,8 @@ public class CameraActivity extends Activity implements CameraManager.CameraRead
                     mShutterButton.setImageDrawable(getResources()
                             .getDrawable(R.drawable.btn_shutter_video));
                 }
+            } else {
+                Log.e(TAG, "Unknown Camera Mode: " + mCameraMode + " ; No capture transformer");
             }
         }
 
@@ -1294,6 +1270,8 @@ public class CameraActivity extends Activity implements CameraManager.CameraRead
             // Adjust orientationCompensation for the native orientation of the device.
             Configuration config = getResources().getConfiguration();
             int rotation = getWindowManager().getDefaultDisplay().getRotation();
+            Util.getDisplayRotation(CameraActivity.this);
+
             boolean nativeLandscape = false;
 
             if (((rotation == Surface.ROTATION_0 || rotation == Surface.ROTATION_180)
diff --git a/src/org/cyanogenmod/focal/CameraManager.java b/src/org/cyanogenmod/focal/CameraManager.java
index 19006e8..7fe7e93 100644
--- a/src/org/cyanogenmod/focal/CameraManager.java
+++ b/src/org/cyanogenmod/focal/CameraManager.java
@@ -76,11 +76,11 @@ public class CameraManager {
     private CameraReadyListener mCameraReadyListener;
     private Handler mHandler;
     private Context mContext;
-    private boolean mCameraOpen;
     private boolean mIsModeSwitching;
     private List<NameValuePair> mPendingParameters;
     private boolean mIsResuming;
     private CameraRenderer mRenderer;
+    private boolean mIsRecordingHint;
 
     public interface PreviewPauseListener {
         /**
@@ -168,7 +168,7 @@ public class CameraManager {
         mPendingParameters = new ArrayList<NameValuePair>();
         mParametersThread.start();
         mIsResuming = false;
-        mCameraOpen = false;
+        mIsRecordingHint = false;
         mRenderer = new CameraRenderer();
     }
 
@@ -199,7 +199,6 @@ public class CameraManager {
                         return;
                     }
                     mCamera = Camera.open(cameraId);
-                    mCameraOpen = true;
                     Log.v(TAG, "Camera is open");
 
                     mCamera.enableShutterSound(false);
@@ -318,7 +317,6 @@ public class CameraManager {
         if (mCamera != null && mCameraReady) {
             Log.v(TAG, "Releasing camera facing " + mCurrentFacing);
             mCamera.release();
-            mCameraOpen = false;
             mCamera = null;
             mParameters = null;
             mPreview.notifyCameraChanged(false);
@@ -352,6 +350,7 @@ public class CameraManager {
                         mPreview.notifyPreviewSize(width, height);
 
                         if (mIsResuming) {
+                            updateDisplayOrientation();
                             mCamera.startPreview();
                             mIsResuming = false;
                         }
@@ -441,7 +440,7 @@ public class CameraManager {
         int previewHeight = previewSize.height;
 
         // Convert YUV420SP preview data to RGB
-        if (data != null) {
+        if (data != null && data.length > 8) {
             Bitmap bitmap = Util.decodeYUV420SP(mContext, data, previewWidth, previewHeight);
             if (mCurrentFacing == Camera.CameraInfo.CAMERA_FACING_FRONT) {
                 // Frontcam has the image flipped, flip it back to not look weird in portrait
@@ -492,10 +491,13 @@ public class CameraManager {
      * Takes a snapshot
      */
     public void takeSnapshot(Camera.ShutterCallback shutterCallback,
-            Camera.PictureCallback raw, Camera.PictureCallback jpeg) {
+                             Camera.PictureCallback raw, Camera.PictureCallback jpeg) {
         Log.v(TAG, "takePicture");
         SoundManager.getSingleton().play(SoundManager.SOUND_SHUTTER);
-        mCamera.takePicture(shutterCallback, raw, jpeg);
+
+        if (mCamera != null) {
+            mCamera.takePicture(shutterCallback, raw, jpeg);
+        }
     }
 
     /**
@@ -569,7 +571,7 @@ public class CameraManager {
         Camera.CameraInfo info =
                 new android.hardware.Camera.CameraInfo();
         Camera.getCameraInfo(mCurrentFacing, info);
-        orientation = (360 - orientation + 45) / 90 * 90;
+        //orientation = (360 - orientation + 45) / 90 * 90;
         int rotation = 0;
         if (info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) {
             rotation = (info.orientation - orientation + 360) % 360;
@@ -617,14 +619,24 @@ public class CameraManager {
                         return;
                     }
 
+                    boolean shouldStartPreview = false;
+
                     if (mode == CameraActivity.CAMERA_MODE_VIDEO) {
-                        params.setRecordingHint(true);
+                        if (!mIsRecordingHint) {
+                            params.setRecordingHint(true);
+                            mIsRecordingHint = true;
+                            mCamera.stopPreview();
+                            shouldStartPreview = true;
+                        }
                     } else {
-                        params.setRecordingHint(false);
+                        if (mIsRecordingHint) {
+                            params.setRecordingHint(false);
+                            mIsRecordingHint = false;
+                            mCamera.stopPreview();
+                            shouldStartPreview = true;
+                        }
                     }
 
-                    mCamera.stopPreview();
-
                     if (mode == CameraActivity.CAMERA_MODE_PANO) {
                         // Apply special settings for panorama mode
                         initializePanoramaMode();
@@ -636,8 +648,9 @@ public class CameraManager {
                     if (mode == CameraActivity.CAMERA_MODE_PICSPHERE) {
                         // If we are in PicSphere mode, set pic size to 640x480 to avoid using
                         // all the phone's resources when rendering, as well as not take 15 min
-                        // to render. Eventually, we could put up a setting somewhere to let users
-                        // rendering super high quality pictures.
+                        // to render. This value can be changed in the settings widget once
+                        // in PicSphere mode, so this value will be changed again when the
+                        // widget loads.
                         params.setPictureSize(640, 480);
                         params.setPreviewSize(640, 480);
 
@@ -647,34 +660,11 @@ public class CameraManager {
                         params.setPreviewSize(mTargetSize.x, mTargetSize.y);
                     }
 
-                    // Rotate the display to 90 degrees
-                    android.hardware.Camera.CameraInfo info =
-                            new android.hardware.Camera.CameraInfo();
-                    android.hardware.Camera.getCameraInfo(mCurrentFacing, info);
-                    int degrees = 90;
-
-                    int result;
-                    if (info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) {
-                        result = (info.orientation + degrees) % 360;
-                        result = (360 - result) % 360;  // compensate the mirror
-                    } else {  // back-facing
-                        result = (info.orientation - degrees + 360) % 360;
-                    }
-                    mCamera.setDisplayOrientation(result);
-
                     mCamera.setParameters(params);
                     mParameters = mCamera.getParameters();
-                    try {
-                        // PicSphere and Pano renders to a texture, so the preview will
-                        // be started once the SurfaceTexture is ready to receive frames
-                        if (mode != CameraActivity.CAMERA_MODE_PICSPHERE
-                                && mode != CameraActivity.CAMERA_MODE_PANO) {
-                            mCamera.startPreview();
-                        }
 
-                        mPreview.notifyPreviewSize(mTargetSize.x, mTargetSize.y);
-                    } catch (RuntimeException e) {
-                        Log.e(TAG, "Unable to start preview", e);
+                    if (shouldStartPreview) {
+                        mCamera.startPreview();
                     }
                 }
 
@@ -689,6 +679,25 @@ public class CameraManager {
     }
 
     /**
+     * Updates the orientation of the display
+     */
+    public void updateDisplayOrientation() {
+        android.hardware.Camera.CameraInfo info =
+                new android.hardware.Camera.CameraInfo();
+        android.hardware.Camera.getCameraInfo(mCurrentFacing, info);
+        int degrees = Util.getDisplayRotation(null);
+
+        int result;
+        if (info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) {
+            result = (info.orientation + degrees) % 360;
+            result = (360 - result) % 360;  // compensate the mirror
+        } else {  // back-facing
+            result = (info.orientation - degrees + 360) % 360;
+        }
+        mCamera.setDisplayOrientation(result);
+    }
+
+    /**
      * Initializes the Panorama (mosaic) mode
      */
     private void initializePanoramaMode() {
@@ -957,6 +966,7 @@ public class CameraManager {
                         mCamera.setPreviewTexture(mTexture);
 
                         if (startPreview) {
+                            updateDisplayOrientation();
                             mCamera.startPreview();
                             postCallbackBuffer();
                         }
@@ -967,42 +977,6 @@ public class CameraManager {
             }
         }
 
-        public void startPreview() {
-            // Stop preview before making changes
-            synchronized (this) {
-                try {
-                    mCamera.stopPreview();
-                } catch (Exception e) {
-                    // Ignore: tried to stop a non-existent preview
-                }
-
-                if (!mCameraOpen) {
-                    Log.w(TAG, "Camera not open yet, delaying surface update");
-                    mHandler.post(new Runnable() {
-                        @Override
-                        public void run() {
-                            startPreview();
-                        }
-                    });
-                    return;
-                }
-
-                setupCamera();
-
-                // Start preview with new settings
-                try {
-                    mCamera.setPreviewTexture(mTexture);
-                    mCamera.startPreview();
-
-                    mParameters = mCamera.getParameters();
-                    postCallbackBuffer();
-                    requestLayout();
-                } catch (Exception e) {
-                    Log.d(TAG, "Error starting camera preview: " + e.getMessage());
-                }
-            }
-        }
-
         public void postCallbackBuffer() {
             mHandler.post(new Runnable() {
                 @Override
@@ -1048,57 +1022,47 @@ public class CameraManager {
     }
 
     public class CameraRenderer implements GLSurfaceView.Renderer {
+        private final float[] mTransformMatrix;
         int mTexture;
         private SurfaceTexture mSurface;
 
-        private final String VERTEX_SHADER =
-                "attribute vec4 position;" +
-                        "attribute vec2 inputTextureCoordinate;" +
-                        "varying vec2 textureCoordinate;" +
-                        "void main()" +
-                        "{"+
-                        "gl_Position = position;"+
-                        "textureCoordinate = inputTextureCoordinate;" +
-                        "}";
-
-        private final String FRAGMENT_SHADER =
-                "#extension GL_OES_EGL_image_external : require\n"+
-                        "precision mediump float;" +
-                        "varying vec2 textureCoordinate;                            \n" +
-                        "uniform samplerExternalOES s_texture;               \n" +
-                        "void main() {" +
-                        "  gl_FragColor = texture2D( s_texture, textureCoordinate );\n" +
-                        "}";
+        private final static String VERTEX_SHADER =
+                "attribute vec4 vPosition;\n" +
+                        "attribute vec2 a_texCoord;\n" +
+                        "varying vec2 v_texCoord;\n" +
+                        "uniform mat4 u_xform;\n" +
+                        "void main() {\n" +
+                        "  gl_Position = vPosition;\n" +
+                        "  v_texCoord = vec2(u_xform * vec4(a_texCoord, 1.0, 1.0));\n" +
+                        "}\n";
+
+        private final static String FRAGMENT_SHADER =
+                "#extension GL_OES_EGL_image_external : require\n" +
+                        "precision mediump float;\n" +
+                        "uniform samplerExternalOES s_texture;\n" +
+                        "varying vec2 v_texCoord;\n" +
+                        "void main() {\n" +
+                        "  gl_FragColor = texture2D(s_texture, v_texCoord);\n" +
+                        "}\n";
 
         private FloatBuffer vertexBuffer, textureVerticesBuffer;
-        private ShortBuffer drawListBuffer;
         private int mProgram;
         private int mPositionHandle;
-        private int mColorHandle;
         private int mTextureCoordHandle;
+        private int mTransformHandle;
 
         // Number of coordinates per vertex in this array
         static final int COORDS_PER_VERTEX = 2;
         static final float RATIO = 4.0f/3.0f;
 
-        private final float squareVertices[] = {
-                1.0f * RATIO,  -1.0f,
-                1.0f * RATIO,  1.0f,
-                -1.0f,  1.0f,
-                -1.0f,  -1.0f
-        };
+        private final float squareVertices[] =
+                { 1.0f * RATIO, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f * RATIO, -1.0f };
 
-        private final float textureVertices[] = {
-                1, 0,
-                0, 0,
-                0, 1,
-                1, 1
-        };
-
-        private final int vertexStride = COORDS_PER_VERTEX * 4; // 4 bytes per vertex
+        private final float textureVertices[] =
+                { 1.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f };
 
         public CameraRenderer() {
-            // Do nothing here
+            mTransformMatrix = new float[16];
         }
 
         public void onSurfaceCreated(GL10 unused, EGLConfig config) {
@@ -1137,15 +1101,17 @@ public class CameraManager {
             GLES20.glActiveTexture(GLES20.GL_TEXTURE0);
             GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, mTexture);
 
-            mPositionHandle = GLES20.glGetAttribLocation(mProgram, "position");
+            mPositionHandle = GLES20.glGetAttribLocation(mProgram, "vPosition");
+            GLES20.glVertexAttribPointer(mPositionHandle, COORDS_PER_VERTEX, GLES20.GL_FLOAT,
+                    false, 0, vertexBuffer);
             GLES20.glEnableVertexAttribArray(mPositionHandle);
-            GLES20.glVertexAttribPointer(mPositionHandle, COORDS_PER_VERTEX, GLES20.GL_FLOAT, false,vertexStride, vertexBuffer);
 
-            mTextureCoordHandle = GLES20.glGetAttribLocation(mProgram, "inputTextureCoordinate");
+            mTextureCoordHandle = GLES20.glGetAttribLocation(mProgram, "a_texCoord");
+            GLES20.glVertexAttribPointer(mTextureCoordHandle, COORDS_PER_VERTEX, GLES20.GL_FLOAT,
+                    false, 0, textureVerticesBuffer);
             GLES20.glEnableVertexAttribArray(mTextureCoordHandle);
-            GLES20.glVertexAttribPointer(mTextureCoordHandle, COORDS_PER_VERTEX, GLES20.GL_FLOAT, false,vertexStride, textureVerticesBuffer);
 
-            mColorHandle = GLES20.glGetAttribLocation(mProgram, "s_texture");
+            mTransformHandle = GLES20.glGetUniformLocation(mProgram, "u_xform");
         }
 
         public void onDrawFrame(GL10 unused) {
@@ -1153,6 +1119,8 @@ public class CameraManager {
 
             if (mSurface != null) {
                 mSurface.updateTexImage();
+                mSurface.getTransformMatrix(mTransformMatrix);
+                GLES20.glUniformMatrix4fv(mTransformHandle, 1, false, mTransformMatrix, 0);
             }
 
             GLES20.glDrawArrays(GLES20.GL_TRIANGLE_FAN, 0, 4);
@@ -1176,14 +1144,6 @@ public class CameraManager {
 
             GLES20.glGenTextures(1,texture, 0);
             GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, texture[0]);
-            GLES20.glTexParameterf(GLES11Ext.GL_TEXTURE_EXTERNAL_OES,
-                    GL10.GL_TEXTURE_MIN_FILTER,GL10.GL_LINEAR);
-            GLES20.glTexParameterf(GLES11Ext.GL_TEXTURE_EXTERNAL_OES,
-                    GL10.GL_TEXTURE_MAG_FILTER, GL10.GL_LINEAR);
-            GLES20.glTexParameteri(GLES11Ext.GL_TEXTURE_EXTERNAL_OES,
-                    GL10.GL_TEXTURE_WRAP_S, GL10.GL_CLAMP_TO_EDGE);
-            GLES20.glTexParameteri(GLES11Ext.GL_TEXTURE_EXTERNAL_OES,
-                    GL10.GL_TEXTURE_WRAP_T, GL10.GL_CLAMP_TO_EDGE);
 
             return texture[0];
         }
diff --git a/src/org/cyanogenmod/focal/Util.java b/src/org/cyanogenmod/focal/Util.java
index f3b3949..0864efb 100644
--- a/src/org/cyanogenmod/focal/Util.java
+++ b/src/org/cyanogenmod/focal/Util.java
@@ -64,6 +64,7 @@ public class Util {
 
     // Screen size holder
     private static Point mScreenSize = new Point();
+    private static int mRotation = 90;
 
     private static DateFormat mJpegDateFormat = new SimpleDateFormat("yyyyMMdd_HHmmss");
 
@@ -76,19 +77,26 @@ public class Util {
      * @return Orientation angle of the display
      */
     public static int getDisplayRotation(Activity activity) {
-        int rotation = activity.getWindowManager().getDefaultDisplay()
-                .getRotation();
-        switch (rotation) {
-            case Surface.ROTATION_0:
-                return 0;
-            case Surface.ROTATION_90:
-                return 90;
-            case Surface.ROTATION_180:
-                return 180;
-            case Surface.ROTATION_270:
-                return 270;
+        if (activity != null) {
+            int rotation = activity.getWindowManager().getDefaultDisplay()
+                    .getRotation();
+            switch (rotation) {
+                case Surface.ROTATION_0:
+                    mRotation = 0;
+                    break;
+                case Surface.ROTATION_90:
+                    mRotation = 90;
+                    break;
+                case Surface.ROTATION_180:
+                    mRotation = 180;
+                    break;
+                case Surface.ROTATION_270:
+                    mRotation = 270;
+                    break;
+            }
         }
-        return 0;
+
+        return mRotation;
     }
 
     /**
diff --git a/src/org/cyanogenmod/focal/ui/ReviewDrawer.java b/src/org/cyanogenmod/focal/ui/ReviewDrawer.java
index 738fbb7..8c12a8b 100644
--- a/src/org/cyanogenmod/focal/ui/ReviewDrawer.java
+++ b/src/org/cyanogenmod/focal/ui/ReviewDrawer.java
@@ -174,63 +174,62 @@ public class ReviewDrawer extends RelativeLayout {
      * @param images True to get images, false to get videos
      */
     public void updateFromGallerySynchronous(final boolean images) {
-        mImages.clear();
+
         mHandler.post(new Runnable() {
             @Override
             public void run() {
+                mImages.clear();
                 mImagesListAdapter.notifyDataSetChanged();
-            }
-        });
 
-        String[] columns = null;
-        String orderBy = null;
-        if (images) {
-            columns = new String[]{MediaStore.Images.Media.DATA, MediaStore.Images.Media._ID};
-            orderBy = MediaStore.Images.Media.DATE_TAKEN + " ASC";
-        } else {
-            columns = new String[]{MediaStore.Video.Media.DATA, MediaStore.Video.Media._ID};
-            orderBy = MediaStore.Video.Media.DATE_TAKEN + " ASC";
-        }
 
-        // Select only the images that has been taken from the Camera
-        ContentResolver cr = getContext().getContentResolver();
-        if (cr == null) {
-            Log.e(TAG, "No content resolver!");
-            return;
-        }
-        Cursor cursor = null;
+                String[] columns = null;
+                String orderBy = null;
+                if (images) {
+                    columns = new String[]{MediaStore.Images.Media.DATA, MediaStore.Images.Media._ID};
+                    orderBy = MediaStore.Images.Media.DATE_TAKEN + " ASC";
+                } else {
+                    columns = new String[]{MediaStore.Video.Media.DATA, MediaStore.Video.Media._ID};
+                    orderBy = MediaStore.Video.Media.DATE_TAKEN + " ASC";
+                }
 
-        if (images) {
-            cursor = cr.query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, columns,
-                    MediaStore.Images.Media.BUCKET_DISPLAY_NAME + " LIKE ?",
-                    new String[]{GALLERY_CAMERA_BUCKET}, orderBy);
-        } else {
-            cursor = cr.query(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, columns,
-                    MediaStore.Video.Media.BUCKET_DISPLAY_NAME + " LIKE ?",
-                    new String[]{GALLERY_CAMERA_BUCKET}, orderBy);
-        }
+                // Select only the images that has been taken from the Camera
+                ContentResolver cr = getContext().getContentResolver();
+                if (cr == null) {
+                    Log.e(TAG, "No content resolver!");
+                    return;
+                }
+                Cursor cursor = null;
 
-        if (cursor == null) {
-            Log.e(TAG, "Null cursor from MediaStore!");
-            return;
-        }
+                if (images) {
+                    cursor = cr.query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, columns,
+                            MediaStore.Images.Media.BUCKET_DISPLAY_NAME + " LIKE ?",
+                            new String[]{GALLERY_CAMERA_BUCKET}, orderBy);
+                } else {
+                    cursor = cr.query(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, columns,
+                            MediaStore.Video.Media.BUCKET_DISPLAY_NAME + " LIKE ?",
+                            new String[]{GALLERY_CAMERA_BUCKET}, orderBy);
+                }
+
+                if (cursor == null) {
+                    Log.e(TAG, "Null cursor from MediaStore!");
+                    return;
+                }
 
-        final int imageColumnIndex = cursor.getColumnIndex(images ?
-                MediaStore.Images.Media._ID : MediaStore.Video.Media._ID);
-        final Cursor finalCursor = cursor;
+                final int imageColumnIndex = cursor.getColumnIndex(images ?
+                        MediaStore.Images.Media._ID : MediaStore.Video.Media._ID);
 
-        mHandler.post(new Runnable() {
-            @Override
-            public void run() {
-                for (int i = 0; i < finalCursor.getCount(); i++) {
-                    finalCursor.moveToPosition(i);
+                for (int i = 0; i < cursor.getCount(); i++) {
+                    cursor.moveToPosition(i);
 
-                    int id = finalCursor.getInt(imageColumnIndex);
+                    int id = cursor.getInt(imageColumnIndex);
                     if (mReviewedImageId <= 0) {
                         mReviewedImageId = id;
                     }
                     addImageToList(id);
+                    mImagesListAdapter.notifyDataSetChanged();
                 }
+
+                scrollToLatestImage();
             }
         });
     }
@@ -370,26 +369,26 @@ public class ReviewDrawer extends RelativeLayout {
         animate().setDuration(DRAWER_TOGGLE_DURATION).setInterpolator(new DecelerateInterpolator())
                 .translationY(-getMeasuredHeight()).alpha(0.0f)
                 .setListener(new Animator.AnimatorListener() {
-            @Override
-            public void onAnimationStart(Animator animator) {
+                    @Override
+                    public void onAnimationStart(Animator animator) {
 
-            }
+                    }
 
-            @Override
-            public void onAnimationEnd(Animator animator) {
-                setVisibility(View.GONE);
-            }
+                    @Override
+                    public void onAnimationEnd(Animator animator) {
+                        setVisibility(View.GONE);
+                    }
 
-            @Override
-            public void onAnimationCancel(Animator animator) {
+                    @Override
+                    public void onAnimationCancel(Animator animator) {
 
-            }
+                    }
 
-            @Override
-            public void onAnimationRepeat(Animator animator) {
+                    @Override
+                    public void onAnimationRepeat(Animator animator) {
 
-            }
-        }).start();
+                    }
+                }).start();
     }
 
     /**
@@ -508,7 +507,7 @@ public class ReviewDrawer extends RelativeLayout {
                     final Bitmap thumbnail = CameraActivity.getCameraMode() ==
                             CameraActivity.CAMERA_MODE_VIDEO ? (MediaStore.Video.Thumbnails
                             .getThumbnail(getContext().getContentResolver(),
-                            mImages.get(position), MediaStore.Video.Thumbnails.MINI_KIND, null))
+                                    mImages.get(position), MediaStore.Video.Thumbnails.MINI_KIND, null))
                             : (MediaStore.Images.Thumbnails.getThumbnail(getContext()
                             .getContentResolver(), mImages.get(position),
                             MediaStore.Images.Thumbnails.MINI_KIND, null));
@@ -581,59 +580,59 @@ public class ReviewDrawer extends RelativeLayout {
         private ImageView mImageView;
         private GestureDetector.SimpleOnGestureListener mListener =
                 new GestureDetector.SimpleOnGestureListener() {
-            private final float DRIFT_THRESHOLD = 80.0f;
-            private final int SWIPE_THRESHOLD_VELOCITY = 800;
+                    private final float DRIFT_THRESHOLD = 80.0f;
+                    private final int SWIPE_THRESHOLD_VELOCITY = 800;
 
-            @Override
-            public boolean onDown(MotionEvent motionEvent) {
-                return true;
-            }
+                    @Override
+                    public boolean onDown(MotionEvent motionEvent) {
+                        return true;
+                    }
 
-            @Override
-            public void onShowPress(MotionEvent motionEvent) {
+                    @Override
+                    public void onShowPress(MotionEvent motionEvent) {
 
-            }
+                    }
 
-            @Override
-            public boolean onSingleTapUp(MotionEvent motionEvent) {
-                return false;
-            }
+                    @Override
+                    public boolean onSingleTapUp(MotionEvent motionEvent) {
+                        return false;
+                    }
 
-            @Override
-            public boolean onScroll(MotionEvent ev1, MotionEvent ev2, float vX, float vY) {
-                if (Math.abs(ev2.getX() - ev1.getX()) > DRIFT_THRESHOLD) {
-                    return false;
-                }
+                    @Override
+                    public boolean onScroll(MotionEvent ev1, MotionEvent ev2, float vX, float vY) {
+                        if (Math.abs(ev2.getX() - ev1.getX()) > DRIFT_THRESHOLD) {
+                            return false;
+                        }
 
-                mImageView.setTranslationY(ev2.getRawY() - ev1.getRawY());
-                float alpha = Math.max(0.0f, 1.0f - Math.abs(mImageView.getTranslationY()
-                            / mImageView.getMeasuredHeight())*2.0f);
-                mImageView.setAlpha(alpha);
+                        mImageView.setTranslationY(ev2.getRawY() - ev1.getRawY());
+                        float alpha = Math.max(0.0f, 1.0f - Math.abs(mImageView.getTranslationY()
+                                / mImageView.getMeasuredHeight())*2.0f);
+                        mImageView.setAlpha(alpha);
 
-                return true;
-            }
+                        return true;
+                    }
 
-            @Override
-            public void onLongPress(MotionEvent motionEvent) {
+                    @Override
+                    public void onLongPress(MotionEvent motionEvent) {
 
-            }
+                    }
 
-            @Override
-            public boolean onFling(MotionEvent ev1, MotionEvent ev2, float vX, float vY) {
-                if (Math.abs(ev2.getX() - ev1.getX()) > DRIFT_THRESHOLD) {
-                    return false;
-                }
+                    @Override
+                    public boolean onFling(MotionEvent ev1, MotionEvent ev2, float vX, float vY) {
+                        if (Math.abs(ev2.getX() - ev1.getX()) > DRIFT_THRESHOLD) {
+                            return false;
+                        }
 
-                if (Math.abs(vY) > SWIPE_THRESHOLD_VELOCITY) {
-                    mImageView.animate().translationY(-mImageView.getHeight()).alpha(0.0f)
-                            .setDuration(300).start();
-                    removeReviewedImage();
-                    return true;
-                }
+                        if (Math.abs(vY) > SWIPE_THRESHOLD_VELOCITY) {
+                            mImageView.animate().translationY(-mImageView.getHeight()).alpha(0.0f)
+                                    .setDuration(300).start();
+                            removeReviewedImage();
+                            return true;
+                        }
 
-                return false;
-            }
-        };
+                        return false;
+                    }
+                };
 
         public ThumbnailTouchListener(ImageView iv) {
             mImageView = iv;
-- 
1.8.3.4

